2018年11月6日
15:53
分区演示的第1 页
待办：
ProductApply:173
<p>待办审批数：{{processDataInUnfinish.length}}</p>
<ex-table:data="paginationData2"每个分页内显示的processDataInUnfinish
<el-table-columnlabel="进程状态"prop="processStatus":formatter="processStatusFormat"></el-table-column>
单击记录handleCurrentChange2
待办描述流程状态<li><label>流程状态：</label>{{flowStatusFromat(formEdit2.currentFlowStatus)}}</li>
待办表单操作<divv-show="paginationData2.length>0">
<el-form:model="formEdit2" :rules="mainVerifyRule" ref="formEdit2">
<el-radio-groupv-model="radioSelect" @change="changeNextStep"
<el-radiolabel="approved":disabled="approvedRadio" v-show="isShowApprovedRadio">通过</el-radio>
提交
<el-buttontype="primary"@click="handleProcess('formEdit2')" :disabled="handleProcessButton">确定</el-button>
FlowApplyOp.getFlowByFlowId(val.flowId) 返回数据赋值给formEdit2
单击行的操作 handleCurrentChange2
busiId 流程类别
flowId 流程Id
processId 进程Id
当前处理人和流程状态是取得currentFlowStatus和currentProcessTo
而this.formEdit2.processTo = val.processTo;
this.currentflowStep = val.flowStep;
this.nextflowStep = this.getNextStep(val.flowStep, 'approved');
申请加入群组
常规审批流程
表格行信息
提交的操作handleProcess('formEdit2')
switch(this.currentflowStep)
letformtemp = {};
提交的数据formtemp = {}
this.diffProcessByHandled(this.userId);
this.fetchFlowDataByApply();
重新获取待办
流程状态问题：
flowStep
processStatus
currentFlowStep
在行信息中
currentFlowStatus
状态
currentFlowStep
步骤
通过流程Id获取流程状态信息
同步页面20181103
2018年11月3日
10:43
分区project 的第2 页
已办
表格数据tableData3
单击记录handleCurrentChange3
<el-table-columnlabel="进程状态"prop="processStatus":formatter="processStatusFormat"></el-table-column>
前后端联调问题点：
分区project 的第3 页
插入树121
<divid="side">
<my-treelevel=5@node-click="handleNodeClick" ref="tree_pro"/>
</div>
letcurrent = this.selected
confirmButtonText: '确定',
cancelButtonText: '取消',
type: 'warning'
this.$confirm('您还有指标项未保存，确定需要离开该页面吗?', '提示', {
this.paramCommit = [];
this.selected = e;
}).then(() =>{
this.$refs.tree_pro.setCurrentNode(current)
Vue.nextTick(() =>{
})
}).catch(_ =>{
})
if(this.paramCommit.length > 0) {
this.selected = e;
} else{
}
handleNodeClick(e) {
}
<el-tree:data="data":props="defaultProps"@node-click="handleNodeClick"></el-tree>
Data:[{label:'1',children:[{label:'1-1'}]}]
Node-click 节点被点击的回调
this.$emit("node-click", e)
handleNodeClick(e) {
}
letcookietemp = e;
setCookie("CLOUDATE_INDICATOR_PROJECT_SELECTED_LEVEL3", JSON.stringify(cookietemp));
if(this.$parent.$refs.tree_pro.level==3){
setCookie("CLOUDATE_INDICATOR_PROJECT_SELECTED_LEVEL5", JSON.stringify(cookietemp));
}elseif(this.$parent.$refs.tree_pro.level==5){
}
returnthis.$refs.tree.setCurrentNode(e)
setCurrentNode: function(e) {
},
value: '1',
树节点的pointType ：
label: '装备指标库节点'
}, {
value: '2',
label: '产品指标库节点'
}, {
value: '3',
label: '库目录节点'
}
value: '4',
label: '装备工程节点'
}, {
value: '5',
label: '产品工程节点'
}, {
value: '6',
label: '目录节点'
}
参数集与树
2018年11月5日
14:13
分区project 的第4 页
提交删除操作
var_this = this
console.log(row)
varcommitData = {}
bomName:row.bomCode,
bomType:row.assemblyType,
fileName:row.fileName,
level:'file',
projName:this.productName,
projVersion:this.productVersion,
softNo:row.softwareNo,
userId:this.$store.state.username
commitData = {
};
constdeleteRowPath=`${C.paramlibAddr}/api/v1/project/deletefiles`;
return(item.md5 != row.md5)
_this.softwaresListData = _this.softwaresListData.filter(item =>{
});
setTimeout(function(){
},500)
AXIOS.post(deleteRowPath,commitData).then(r=>{
message: "删除成功",
title: "操作提示",
type: "success",
offset: 100
this.$notify({
})
}).then(r=>{
message: "删除失败:"+ e,
title: "操作提示",
offset: 100
this.$notify.error({
})
}).catch(e =>{
})
this.$confirm('确认删除？').then(_ =>{
console.log('取消删除')
}).catch(_=>{
})
deleteRow(row){
},
注意事项：
1ajax里面使用_this替换this
2post请求
3页面刷新setTimeout，使用filter重新获取表格数组
4提交成功与失败要都要有提示
varpath = C.paramlibAddr + `/api/v1/filetrans/importFileForParamApply/${productType}/${productId}/${projectName}/${version}/${updatedBy}/${transRule}`;
constpath = `${C.paramlibAddr}/api/v1/filetrans/uploadfile/binary?project=${project}&version=${version}&softCode=${softcode}&uploadBy=${uploadby}&fileType=${filetype}`
exportfunctiondeleteParamApply(id: number) {
constpath = `${C.paramlibAddr}/api/v1/paramapply/deleteParamApply/${id}`
returnAXIOS.get(path);
}
exportfunctionupdateParamApply(model: any) {
constpath = `${C.paramlibAddr}/api/v1/paramapply/updateParamApply`
returnAXIOS.post(path, model);
}
模糊搜索工程列表
工程相关/api/v1/project/getProjects
http://10.249.1.162:30072/api/v1/project/getProjects?name=test
computed: {
initProductNameFrom:function(){
if(this.selected){
if(this.selected.pointType == '4'|| this.selected.pointType == '5'){
returnthis.selected.name;
}else{
return"";
}
}else{
return"";
search
2018年11月6日
17:33
分区project 的第5 页
}else{
return"";
}
}else{
return"";
}
},
分区project 的第6 页
vararr,reg=newRegExp("(^|)"+name+"=([^;]*)(;|$)");
return(arr[2]);
if(arr=document.cookie.match(reg))
returnnull;
else
exportfunctiongetCookie(name){
}
varexpdate = newDate();
if(window.navigator.userAgent.indexOf('Chrome') !== -1) {
expiredays = expiredays + 1/3;
//chrome有时差8个时区
}
expdate.setDate(expdate.getDate()+expiredays);
document.cookie=c_name+"="+escape(value)+((expiredays==null)?"":";expires="+expdate.toGMTString());
exportfunctionsetCookie(c_name,value,expiredays){
}
//删除cookies
varexp = newDate();
exp.setTime(exp.getTime() -1);
varcval=getCookie(name);
if(cval!=null)
document.cookie= name + "="+cval+";expires="+exp.toGMTString();
exportfunctiondelCookie(name){
}
提交登录
this.isloading = true;
letname = this.userinfo.name;
letpaswwd = this.userinfo.passwd;
lettype = this.userinfo.type;
letpasswdEncoded = Utils.encrypt(paswwd, "abcdefgabcdefg12");
userId: name,
encodedPasswd: passwdEncoded,
loginType: type
letuserLoginContent = {
};
this.isloading = false;
letresult = re.data.result;
letmessage = re.data.message;
this.$store.commit("setlogin", true);
this.$store.commit("setuser", name);
setCookie("LAST_USER", userLoginContent.userId,1/48);
path: "/30"
this.$router.push({
});
if(result) {
this.isshow = true;
this.$store.commit("setlogin", false);
} else{
}
checkUserLogin(userLoginContent).then(re =>{
});
onSubmit: function() {
}
console.log("to:", to.fullPath)
//对路由进行验证
vartemp = getCookie("LAST_USER");
// if (store.state.islogin || temp) {
store.state.islogin = true;
store.state.username = temp;
//正常跳转到你设置好的页面
next()
if(temp) {
//未登录则跳转到登陆界面，query:{ Rurl: to.fullPath}表示把当前路由信息传递过去方便登录后跳转回来；
store.state.islogin = false;
next({ path: '/login', query: { Rurl: to.fullPath } })
}else{
};
if(to.matched.some(m =>m.meta.auth)) {
next()
} else{
}
router.beforeEach((to, from, next) =>{
})
刷新页面或跳转页面：
路由：
to：
this.$router.push({
path: '/30/release'
});
登录与刷新
2018年11月6日
19:50
分区project 的第7 页
this.$router.push({
path: '/30/release'
});
<divv-if="!config.children" @click="clickNav(config_index, config.desc, 0, config.desc)">{{config.desc}}</div>
onClickHref: function(navs) {
this.$router.push({ path: '/'+ navs })
}
this.$emit("clickHref", this.current_navs_index.join(""));
this.current_navs_index = [first_index, second_index];
clickNav: function(first_index, first, second_index, second) {
分区project 的第8 页
1 群组信息
2 库指标列表
3 用户针对此群组的权限
点击库节点3个请求：
点击树节点，
1 节点信息
2 群组信息其中有groupId
3 版本列表bom列表
4 指标库列表
5 查看群组中的用户及其他角色
6用户针对此群组的权限
7对应bom指标列表
点击装备、产品工程节点：
用户登录：userId
选择工程：根据工程名称获取群组信息，其中有groupId
userId对应有roleId和roleName
根据groupId获取群组中的用户及角色
根据groupId和userId查询用户在群组的权限列表
Privilege 为1代表有权限
privilegeId 标识操作类型
1 根据用户Id获取流程列表
2 涉及该用户的处理的所有进程
3 获取业务角色
进入页面发起的请求
节点类型pointType
value: '1',
label: '装备指标库节点'
}, {
value: '2',
label: '产品指标库节点'
}, {
value: '3',
label: '库目录节点'
}
value: '4',
label: '装备工程节点'
}, {
value: '5',
label: '产品工程节点'
}, {
value: '6',
label: '目录节点'
}
角色对应的权限
api/v1/right/group/user/prilivelge?groupId=404&userId=l00311151&privilegeId=15
查询某用户对某群组的某个资源是否具有权限
流程
2018年11月9日
9:53
分区project 的第9 页
UserRightOp.getprilivelgesBygroupIdAndUserId(this.groupId, this.userId).then(r =>{
lettemp = r.data.filter(item =>{
return(item.privilege == "1")
});
this.authorityArray = temp.map(item =>item.privilegeId)
})
ishasPrilivelge(privilegeId) {
this.isPermit = false;
this.authorityArray.forEach(s =>{
if(s == privilegeId) {
this.isPermit = true;
}
})
},
判定当前用户userId是否是某个工程的se
根据工程名称获取groupId
根据groupId获取角色se对应的userId userRoles=[]
比对userId
根据工程名获取groupId
根据groupId和userId获取权限列表
判断权限列表内是否有se的所有权限
只有se和开发人员有资源操作权利，只要判定当前用户有其中一项权利即可
if Items.userId==userId
isHasRight = true
If item.roleName = 'se'
items.roles.forEach(item=>{
userRoles.forEach(items=>{
if Items.userId==userId
isHasRight = true
If item.roleName = 'se'
items.roles.forEach(item=>{
userRoles.forEach(items=>{
用some函数重写
//watch select的变化
this.getGroupByGroupName();
selected: function (val) {
权限问题
//根据群组名拿到群组id
this.groupId = r.data.groupId
this.getAllAuthorityinGroupByuserId();
UserRightOp.getGroupByGroupName(this.selected.name).then(
getGroupByGroupName() {
//根据群组id拿到具有权限的操作privilegeId组成的数组
getAllAuthorityinGroupByuserId(
UserRightOp.getprilivelgesBygroupIdAndUserId(this.groupId, this.userId).then(r => {
let temp = r.data.filter(item => {
return (item.privilege == "1")
});
this.authorityArray = temp.map(item => item.privilegeId)
})
//切换群组的时候把用户的权限带回来watch
authorityArray: function (val) {
val.forEach(s => {
if (s == 12) {
this.isInsertForbidden = false;
if (this.selected.children.length > 0 || this.product_id == "" || (this.selected
.children.length == 0 && (this.selected.pointType == "2" || this.selected
.pointType == "1"))) {
this.isInsertForbidden = true;
}
} else if (s == 15) {
this.isDeleteForbidden = false;
if (this.selected.children.length > 0 || (this.selected.children.length == 0 &&
(this.selected.pointType == "2" || this.selected.pointType == "1"))) {
this.isDeleteForbidden = true;
}
分区project 的第10 页
}
} else if (s == 13) {
this.isCreateForbidden = false;
if (this.selected.children.length > 0 || (this.selected.children.length == 0 &&
(this.selected.pointType == "2" || this.selected.pointType == "1"))) {
this.isCreateForbidden = true;
}
} else if (s == 14) {
this.isSaveForbidden = false;
if (this.selected.children.length > 0) {
this.isSaveForbidden = true;
}
}
})
},
//判断用户是否具有某个权限.
//根据权限id获取是否有此权限
ishasPrilivelge(privilegeId) {
this.isPermit = false;
this.authorityArray.forEach(s => {
if (s == privilegeId) {
this.isPermit = true;
}
})
},
分区project 的第11 页
groups.null = []
if(!groups.null) {
}
group.null.push()
如果对象里面不存在某个属性添加此属性，并赋值
指标集
2018年11月9日
10:32
分区project 的第12 页
userArr:[]
loginRember:false
data：
Let arr = unescape(getCookie("REMBER_USER"))
This.userArr = JSON.parse(arr) || []
Created(){
}
Return item.name ===val.name
If(this.userArr.some(function(item){
console.log('存在不需要添加',state.userArr)
})){
This.userArr.push(val)
}else{
}
pushUser(val){//记住我
}
Return item.name !==val.name
If(this.userArr.some(function(item){
Return item.name !== val.name
This.userArr = this.userArr.filter(function(item){
})
})){
// console.log('不存在不需要剔除',state.userArr)
}else{
}
pullUser(val){//无记住我
}
this.loginRember = true;
this.userinfo.name = val;
returnitem.name == val
varselectedUser = this.userArr.filter(function(item) {
})[0]
this.userinfo.passwd = selectedUser.passwd;
this.userinfo.type = selectedUser.type;
selectUser(val) { //选择记忆用户名
},
letname = this.userinfo.name;
letpaswwd = this.userinfo.passwd;
lettype = this.userinfo.type;
letremberUser = JSON.parse(JSON.stringify(this.userinfo))
userId: name,
encodedPasswd: passwdEncoded,
loginType: type
letuserLoginContent = {
};
letresult = re.data.result;
this.pushUser(remberUser)
if(this.loginRember) {
this.pullUser(remberUser)
} else{
}
letremberUserList = JSON.stringify(this.userArr)
setCookie("REMBER_USER", remberUserList,365);
path: "/30"
this.$router.push({
});
if(result) {
}
checkUserLogin(userLoginContent).then(re =>{
})
onSubmit: function() {
}
Methods:{
记住我
2018年11月21日
16:27
分区project 的第13 页
row-click函数输入的参数row是每行的key
在app.vue文件中添加
.el-table th.gutter{
display:table-cell !important;
}
.el-table colgroup.gutter{
display:table-cell !important;
}
表格筛选造成的表头错位问题：
列筛选：
定义筛选列
<el-table-columnprop="workProcedure"label="工序"width="80":filters="filtersWorkProcedure"
:filter-method="filterHandler1"></el-table-column>
定义筛选项数组
this.editArr(item.workProcedure,arr2,this.filtersWorkProcedure)
//{text:`${obj}`,value:`${obj}`}
arr.push(obj)
brr.push({text:`${obj}`,value:`${obj}`})
if(arr.indexOf(obj) === -1) {
}
if(obj){
}
editArr(obj,arr,brr) {//筛选列数组处理,剔除相同项
}
定义筛选方法（固定）
constproperty = column.property;
returnrow[property] === value;
filterHandler1(value, row, column) {
},
表格样式：
:row-style='rowClass'
return{
"font-size": "14px"
}
rowClass: function() {
}
行合并：
定义合并方法
<el-table:data="softwaresListData" :span-method="arraySpanMethod"
每列合并的数组
varoneArr = [];
vartwoArr = [];
varoneIndex = 0;
vartwoIndex = 0;
oneArr.push(1);
oneIndex = index;
if(index===0){
oneArr[oneIndex]+=1;
oneArr.push(0);
if(item[key1]===data[index-1][key1]){
oneArr.push(1);
oneIndex = index;
}else{
}
}else{
}
twoArr.push(1);
twoIndex = index;
if(oneArr[index]>0){
twoArr[twoIndex]+=1;
twoArr.push(0);
if(item[key2]===data[index-1][key2]){
twoArr.push(1);
twoIndex = index;
}else{
}
}else{
}
data.forEach((item,index)=>{
getSpanArr(data, key1,key2) {//表格行合并预处理函数,key1第一列的key值，key2第二列的key值
筛选导致需要重新计算合并行问题
筛选后显示出来的表格数据就不是原来的table数据；
不能再使用之前的数据获取行合并合并数组
筛选不会更改原始数据只会更改显示数据
filtered-value选中的数据过滤项，如果需要自定义表头过滤的渲染方式，可能会需要此属性。页面加载显示的过滤选项
filter-method 数据过滤使用的方法，如果是多选的筛选项，对每一条数据会执行多次，任意一次返回true 就会显示。
clearFilter 用于清空过滤条件，数据会恢复成未过滤的状态
filter-change 当表格的筛选条件发生变化的时候会触发该事件，参数的值是一个对象，对象的key 是column 的columnKey，对应的value 为用户选择的筛选条件的数组。
column-key='softwareType'
表格数据经过筛选后两种处理方法
1重新获取表格数据，再次渲染表格
<el-table :data="softwaresListData" :max-height="searchFileTableHeight" :span-method="arraySpanMethod" @filter-change="filterChange"
2重新获取行合并的合并数组
highlight-current-row border :row-style='rowClass' ref='table'>
<el-table-column prop="softwareType" label="软件类型" width="110" :filters="filtersSoftwareType"
:filter-method="filterHandler3" column-key='softwareType' >
filterChange(obj){
// console.log('change',obj)
if(obj.softwareType.length>0){
this.filterTableData=this.softwaresListData.filter((items)=>{
return obj.softwareType.indexOf(items.softwareType) > -1
})
}else{
this.filterTableData=this.softwaresListData
}
},
var data = this.getSpanArr(this.filterTableData, 'assemblyType','bomCode','workProcedure','stationCode');
行合并数组，使用过滤后的数据进行计算
this.$refs.table.clearFilter();
注意：切换表格内容筛选重置
filterHandler(value, row, column) {
筛选
const property = column.property;
}
return row[property] === value;
远程模糊搜索功能
1 el-autocomplete :fetch-suggestions="projectSearch"
2 watch 检测输入框的数据变化，调取后台数据拿到待选数组
4 对待选数组过滤处理
5 调用模糊搜索回调函数
<el-autocomplete ref="product" class="inline-input" v-model="productName" :fetch-suggestions="projectSearch"
placeholder="请输入工程名称" @select="selectProduct" :trigger-on-focus="false" ></el-autocomplete>
watch：
productName: function (newVal) {
this.getSelectArr(newVal)
预处理时间
vartime = newDate(item.createdTime.time).toLocaleString()
Vue.set(item,'creatTime',time)
value.forEach((item)=>{
})
returnvalue
dataedit(value){
},
this.tableData = this.dataedit(re.data)
表格数据在获取后预处理：
手动添加一个el-table-column，设type属性为selection即可
多选
手动添加一个el-table-column，设type属性为index即可
序号
Table
2018年11月3日
15:37
分区element 的第14 页
twoArr.push(1);
twoIndex = index;
}else{
}
}
})
oneArr:oneArr,
twoArr:twoArr
return{
}
},
合并方法：
vararrData = this.getSpanArr(this.softwaresListData, 'assemblyType','bomCode')
varfirst = arrData.oneArr
varsecond = arrData.twoArr
constrow = first[rowIndex];
constcol = row > 0? 1: 0;
rowspan: row,
colspan: col
return{
}
if(columnIndex === 0) {
constrow = second[rowIndex];
constcol = row > 0? 1: 0;
rowspan: row,
colspan: col
return{
}
} elseif(columnIndex === 1) {
}
arraySpanMethod: function({row,column,rowIndex,columnIndex}) {
},
<el-buttontype="text"@click.stop="deleteRow(scope.row)">删除</el-button>
<templateslot-scope="scope">
</template>
<el-table-columnlabel="操作"width="100">
</el-table-column>
var_this = this//调用接口且使用本组件数据的时候要使用_this
// console.log(row)
varcommitData = {}
bomName: row.bomCode,
bomType: row.assemblyType,
fileName: row.fileName,
level: 'file',
projName: this.productName,
projVersion: this.productVersion,
softNo: row.softwareNo,
userId: this.$store.state.username
commitData = {
};
constdeleteRowPath = `${C.paramlibAddr}/api/v1/project/deletefiles`;
return(item.md5 != row.md5)
_this.softwaresListData = _this.softwaresListData.filter(item =>{
});
setTimeout(function() {//调取后台刷新页面，要使用异步
}, 500)
AXIOS.post(deleteRowPath, commitData).then(r =>{
message: "删除成功",
title: "操作提示",
type: "success",
offset: 100
this.$notify({
})
}).then(r =>{
message: "删除失败:"+ e,
title: "操作提示",
offset: 100
this.$notify.error({
})
}).catch(e =>{
})
this.$confirm('确认删除？').then(_ =>{
console.log('取消删除')
}).catch(_ =>{
})
deleteRow(row) { //删除表格行
},
@click.native.prevent="deleteRow(scope.$index, tableData4)"
deleteRow(index, tabledata, row) { //删除表格行，只是表格删除，不调用后台
删除行操作：
suggestions="projectSearch"
placeholder="请输入工程名称" @select="selectProduct" :trigger-on-focus="false" ></el-autocomplete>
watch：
productName: function (newVal) {
this.getSelectArr(newVal)
this.productName = ''
this.softwaresData = {}
this.versionsList = []
this.softwaresListData = []
this.productVersion = '';
this.productName = newVal;
this.getVersionsList();
}
getSelectArr(name){
var _this = this
this.restaurants = []
const path = `${C.paramlibAddr}/api/v1/project/getProjects?name=${name}`;
AXIOS.get(path).then(function (response) {
_this.restaurants = response.data;
}).catch(function (err) {
console.log(err);
});
}
projectSearch(queryString, cb) {
// 工程名称模糊搜索
var timeout=''
var resultsLast=[]
var restaurants = this.restaurants;
if(restaurants.length>0){
restaurants.forEach((item)=>{
resultsLast.push({"value":item})
})
}
// console.log(resultsLast)
var results = queryString ? resultsLast.filter(this.createStateFilter(queryString)) : resultsLast;
// console.log(results) //获取到了，但是没有在建议框显示出来是由于待搜索数组格式{"value":""}
// 调用callback 返回建议列表的数据
clearTimeout(timeout);
timeout=setTimeout(()=>{
cb(results);
},500)
},
createStateFilter(queryString) {
return (state) => {
return (state.value.toLowerCase().indexOf(queryString.toLowerCase()) === 0);
};
},
已服务方式调用loading需要异步关闭
指令方式调用与服务方式调用
loading：
<table v-lodaging='loading'>
Data:loading:false
调取数据前
this.loading = true
调取数据后
_this.loading = false
指令方式调用
<table>
调取数据前
Lock:true,
Text:'loading',
Background:''
Const loading = this.$loading({
})
调取数据后
Loading.close()
setTimeout (()=>{
},500)
服务方式调用
自定义列内容：插槽
传入templateslot-scope="scope"
插槽内可以接受到的参数{ scope.row, scope.column, scope.$index }
@click="downloadFileByfileId(scope.$index,scope.row)">{{scope.row.paramId}}
<el-buttontype="text"
</el-button>
<templateslot-scope="scope">
</template>
<el-table-columnlabel="已有文件"prop="paramId">
</el-table-column>
downloadFileByfileId(index, row) {
letfileId = "";
if(typeof(row.curValue) == 'object') {
fileId = (row.curValue).fileId
} else{
fileId = JSON.parse(row.curValue).fileId
}
分区element 的第15 页
})
},
@click.native.prevent="deleteRow(scope.$index, tableData4)"
tabledata.splice(index, 1)
this.$confirm('确认删除？').then(() =>{
})
deleteRow(index, tabledata, row) { //删除表格行，只是表格删除，不调用后台
},
letfileId = "";
if(typeof(row.curValue) == 'object') {
fileId = (row.curValue).fileId
} else{
fileId = JSON.parse(row.curValue).fileId
}
constdownloadPath = `${C.paramlibAddr}/api/v1/filetrans/downloadfile?fileId=${fileId}`;
window.open(downloadPath);
},
几个思路
1 一整行编辑
2 单个单元格编辑
3 表格内容使用input绑定
单元格编辑功能（行编辑）
实现行编辑和还原的思路：
tableData渲染表格
originData应用到还原功能
1拿到的数据备份为两个
深复制行数据到表单formData
获取当前行的index
this.sequenceForm1 = {}
this.editSequenceRowInfo = {}
row:row,
index:index
this.editSequenceRowInfo = {
}
this.editSequenceDialogVisible2 = true
vartempData = JSON.parse(JSON.stringify(row))
this.sequenceForm1 = tempData
editSequenceRow(row, index){//行操作的编辑
},
2编辑行
直接复制数据无法实现表格dom更新
对象使用vue.set替换数据
数组使用splice替换数据，
saveEditSequence(formName){//保存行操作编辑表
vartempData = this.sequenceForm1
this.sequenceTableData.splice(
this.editSequenceRowInfo.index,1,tempData)
this.editSequenceDialogVisible2 = false
if(valid) {
console.log('error submit!!');
returnfalse;
} else {
}
});
this.$refs[formName].validate((valid) => {
},
保存编辑表
原始数据的索引不会更改，表格数据的索引会因为增加或删除导致与原始数据的索引不在对应，
1 在获取数据的时候分别绑定个索引属性
2 在数据字段中找一个不会相同的属性作为行标识
restoreRow1(index,tabledata,row){//行操作的还原
this.sequenceTableData.splice(
index,1,this.sequenceData[index])
//原始数据sequenceData
},
还原行操作
通过双击进行表格编辑，
给数据添加具有唯一性的selfId根据selfId定位在表格中的index
var taIndex = this.sequenceTableData.findIndex(p => p.selfId === row.selfId)
dbclickSequenceRow(row){//双击行进行编辑,
this.editSequenceRow(row,taIndex)
},
restoreRow1(index,tabledata,row){//行操作的还原
//原始数据sequenceData
var taIndex = this.sequenceData.findIndex(p => p.selfId === row.selfId)
this.sequenceTableData.splice(index,1,this.sequenceData[taIndex])
},
createEditSequence(formName){//保存创建表
this.$refs[formName].validate((valid) => {
if (valid) {
var tempData = this.sequenceForm1
tempData.selfId = this.sequenceData.length+1;
tempData.addMark = 'true';
this.sequenceData.unshift(tempData)
this.sequenceTableData.unshift(tempData)
this.editSequenceDialogVisible1 = false
} else {
return false;
}
});
},
分区element 的第16 页
表格行单击触发一种事件，即使没有定义行单击事件
获取行索引的几种方式
1 表格遍历添加索引属性,行或单元格classname和style回调的rowIndex
:row-class-name="tableRowClassName"
tableRowClassName ({row, rowIndex}) {
//把每一行的索引放进row
row.index = rowIndex;
}
2 表格自定义内容插槽的scope.$index
<el-button type="text"
@click.stop="editSequenceRow(scope.row,scope.$index)">编辑</el-button>
<template slot-scope="scope">
</template>
<el-table-column label="操作">
</el-table-column>
3单击双击行如何获取索引，单击双击行触发操作的click事件
:row-class-name="tableRowClassName"
if(this.sequenceData[rowIndex]){
return isChange ? 'warning-row' : ''
let isChange =!this.isObjectValueEqual(row,this.sequenceData[rowIndex]);
return 'warning-row'
}else{
}
tableRowClassName({row,rowIndex}) {//行单元格属性
},
var aProps = Object.getOwnPropertyNames(a);
var bProps = Object.getOwnPropertyNames(b);
// console.log(aProps,bProps)
aProps.pop() // 剔除"__ob__"
bProps.pop()
// console.log('length不同')
return false;
if (aProps.length != bProps.length) {
}
var propName = aProps[i];
// console.log('value不同,不同项：', propName)
return false;
if (a[propName] !== b[propName]) {
}
for (var i = 0; i < aProps.length; i++) {
}
return true;
if(a&&b){//表格数据不是空
return true;
}else{
}
isObjectValueEqual(a, b) {//比较两个对象是否相同
},
给编辑的行添加属性
分区element 的第17 页
分区element 的第18 页
表单验证
通过rules属性传入约定的验证规则，并将 Form-Item 的prop属性设置为需校验的字段名即可
<el-form :model="ruleForm" :rules="rules"ref="formName" status-icon
<el-form-itemlabel="活动名称"prop="name"> <el-input v-model="ruleForm.name"></el-input> </el-form-item>
<el-date-picker type="date" placeholder="选择日期" v-model="ruleForm.date1" style="width: 100%;"></el-date-picker>
<el-form-item prop="date1">
</el-form-item>
<el-time-picker type="fixed-time" placeholder="选择时间" v-model="ruleForm.date2" style="width: 100%;"></el-time-picker>
<el-form-item prop="date2">
</el-form-item>
<el-form-itemlabel="活动时间"required>
</el-form-item>
<el-button type="primary" @click="submitForm('formName')">立即创建</el-button>
<el-button @click="resetForm('formName')">重置</el-button>
<el-form-item>
</el-form-item>
El-form绑定:model和:rules属性
v-model绑定到el-form-item内的控件
prop绑定到el-form-item上
一个表单项可以包含多个子表单项，prop绑定到子表单项，
status-icon属性为输入框添加了表示校验结果的反馈图标
ruleForm: { name: '', region: '', date1: '', date2: '', delivery: false, type: [], resource: '', desc: '' },
rules: { name: [ { required: true, message: '请输入活动名称', trigger: 'blur' }, { min: 3, max: 5, message: '长度在3 到5 个字符', trigger: 'blur' } ],
data() { return {
alert('submit!');
if (valid) {
console.log('error submit!!');
return false;
} else {
}
this.$refs[formName].validate((valid) => {
});
submitForm(formName) { //提交
},
this.$refs[formName].resetFields();
resetForm(formName) { //重置
}
自定义校验
if (!value) { return callback(new Error('年龄不能为空')); }
callback(new Error('请输入数字值'));
if (!Number.isInteger(value)) {
callback(new Error('必须年满18岁'));
if (value < 18) {
} else {
callback(); //验证通过后这行不能少
}
} else {
}
setTimeout(() => {
}, 1000);
var checkAge = (rule, value, callback) => {
};
rules2: { pass: [ { validator: checkAge , trigger: 'blur' } ],
if (valid) { alert('submit!');
console.log('error submit!!'); return false;
} else {
}
this.$refs[formName].validate((valid) => {
});
submitForm(formName) {
},
<el-form-itemprop="email"label="邮箱"
:rules="[ { required: true, message: '请输入邮箱地址', trigger: 'blur' },
<el-input v-model="dynamicValidateForm.email"></el-input>
{ type: 'email', message: '请输入正确的邮箱地址', trigger: ['blur', 'change'] } ]">
</el-form-item>
<el-form-itemv-for="(domain, index) in dynamicValidateForm.domains":label="'域名' + index":key="domain.key"
:prop="'domains.' + index + '.value'"
<el-input v-model="domain.value"></el-input>
<el-button @click.prevent="removeDomain(domain)">删除</el-button>
:rules="{ required: true, message: '域名不能为空', trigger: 'blur' }">
</el-form-item>
<el-button type="primary" @click="submitForm('dynamicValidateForm')">提交</el-button>
<el-button @click="addDomain">新增域名</el-button>
<el-button @click="resetForm('dynamicValidateForm')">重置</el-button>
<el-form-item>
</el-form-item>
var index = this.dynamicValidateForm.domains.indexOf(item)
this.dynamicValidateForm.domains.splice(index, 1)
if (index !== -1) {
}
removeDomain(item) {
},
{ value: '', key: Date.now() }
this.dynamicValidateForm.domains.push(
addDomain() {
在单个表单项上传递属性的验证规则
单个表单项为什么验证失败的问题，未解决，使用全表单验证替换，同样遇到同样的问题
在表单项的绑定值要使用form对象里值form.projectName
使用computed中间层，要添加get和set
returnthis.form.projectName
get(){
},
set(){
}
projectName:{
},
computed:{
然后监听projectName
由于更改绑定值导致监听失败的处理：
This.form = {}
表单提交后置空，或者打开表单框的时候置空
Computed property "route" was assigned to but it has no setter
一个计算属性，如果没有设置setter,也就是传入的是一个函数，或者传入的对象里没有set 属性，当你尝试直接该改变这个这个计算属性的值，比如在methods方法里面有对这个计算属性赋值的操作
都会报这个错误。
所以要给计算属性添加空set
表单验证失败提示语被遮挡问题
有验证提示没有撑开表单，原因默认的提示语position：absolute
自定义样式
.el-form-item__error{
position:relative;
}
使用store验证字段的唯一性
<form :rules="$store.getters.ruleList"
state:{
SequenceTableData:[]
}
getters: {
// Getter 接受state 作为其第一个参数：
ruleList: state => {
let jsonDate = state.paramValues;
var rules = state.rules;
var regEn = /[`~!@#$%^&*()+<>?:"{},.\/;'[\]]/im; //不允许特殊字符
var regCn = /[·！#￥（——）：；“”‘、，|《。》？、【】[\]]/im; //不允许特殊字符
var regEn2 = /[`~!@#$%^&*()+<>?:"{},\/;'[\]]/im;//不允许特殊字符
rules.testName = [
{
validator:function(rule,value,callback){
if(!value){
callback(new Error('请输入测试项名'))
}
var flag = state.SequenceTableData.some((item)=>{
return item.testName == value
})
if(flag){
callback(new Error('测试项名不能重复'))
}else{
callback()
}
},
trigger:'blur',
required:true
}
];
rules.testEnable = [
{required: true, message: '请选择使能', trigger: 'blur' }
];
rules.paramId2 = [
{
validator:function(rule,value,callback){
if(!value){
callback(new Error('请输入指标名称'))
}else if (!(/^[a-zA-Z]+/).test(value)) {
callback(new Error('请以英文字母开头'))
} else if (regEn.test(value) || regCn.test(value)) {
callback(new Error('不允许包含特殊字符'))
}else {
callback()
};
},
trigger: 'blur',
required: true
}
];
return rules;
},
mutations:{
changeSequenceTableData(state,val){
state.SequenceTableData = val;
}
}
组件中传递最新的SequenceTableData
var commitData = JSON.parse(JSON.stringify(this.sequenceTableData))
commitData.splice(index,1)
this.$store.commit('changeSequenceTableData',commitData);//验证唯一性剔除自身
在data函数中定义验证函数
在return中返回规则
在验证函数内需要使用到return的数据的时候处理方法;
在data的return中使用this.data数据为undefined
改用store传递验证
form
2018年11月5日
15:28
分区element 的第19 页
{ value: '', key: Date.now() }
);
}
动态增减表单项
<el-form-itemv-for="(item,key) inrulesContent.enum"
<el-inputstyle="width: inherit;":ref="'enum'+ key"
v-model="rulesContent.enum[key]"autofocus></el-input>
<el-button@click.prevent="removeDate(item,key)">删除</el-button>
:label="'选项'+ key" :key="key">
</el-form-item>
this.rulesContent.enum.splice(key, 1)
removeDate: function(item, key) {
},
Vue.set(this.rulesContent, 'enum', []);
this.rulesContent.enum.push("");
this.enumList = this.rulesContent.enum;
if(!this.rulesContent.enum) {
this.rulesContent.enum.push("");
this.enumList = this.rulesContent.enum;
if(this.rulesContent.enum.length == 0) {
this.rulesContent.enum.push("");
this.enumList = this.rulesContent.enum;
if(this.rulesContent.enum[this.rulesContent.enum.length -1]) {
title: '警告',
message: '域名不能为空',
type: 'warning',
position: 'bottom-right'
this.$notify({
})
} else{
}
} else{
}
} else{ //删除元素后有数组但数组长度为0的走向问题
}
varref = "enum"+ (this.rulesContent.enum.length -1);
// console.log('refs', this.$refs[ref])
this.$refs[ref][0].focus();
this.$nextTick(() =>{
})
addDate: function() {
},
分区element 的第20 页
<spanclass="title">涉及Bom</span>
<el-checkboxv-for='item insystemData0.relateBomArr' :label="item"><spanclass="checkboxItem">{{item}}</span></el-checkbox>
<el-checkbox-groupv-model="checkBomList" @change="handleCheckedBomChange">
</el-checkbox-group>
<spanclass="checkAllBom">
<el-checkboxv-show="true" :indeterminate="isIndeterminate" v-model="checkAllBom" @change="handleCheckAllChange"><spanclass="checkboxItem">全选</span></el-checkbox>
<spanclass="directive">如果驳回，请选择对应的bom</span>
</span>
handleCheckedBomChange(value){
console.log(value)//
letcheckedCount = value.length;
this.checkAllBom = (checkedCount === this.systemData0.relateBomArr.length);
this.isIndeterminate = (checkedCount > 0&& checkedCount < this.systemData0.relateBomArr.length);
},
handleCheckAllChange(value){
this.checkBomList = value ? this.systemData0.relateBomArr : [];
this.isIndeterminate = false;
},
this.extendColumns2 = value ? this.extendColumns1: [];
item.isShow = value
this.extendColumns1.forEach((item)=>{
})
handleCheckAll(value){//显示列全选
},
console.log(value)
item.isShow = false
this.extendColumns1.forEach((item)=>{
})
item.isShow = true
value.forEach((item)=>{
})
letcheckedCount = value.length;
this.extendColumnShowAll = (checkedCount === this.extendColumns1.length);
handleCheckeColumnChange(value){//显示列group单选
},
// handleCheckeColumnChange1(value){//显示列checkbox单选
// console.log(value)
// },
//在checkbox 上的切换value为true和false，
//在group上的切换value为的选中项目label组成的数组即v-model绑定的数组
//更改这个v-mode的数据会影响到原来的数据
1在不使用group的时候checkbox绑定的值为true和false，切换事件的value为true
2使用group的时候，group绑定的值为选中checkbox中label传递的数据组成的数组，也是切换事件的value
<iclass="el-icon-arrow-down el-icon--right"></i>
<el-buttontype="primary">显示列
</el-button>
<el-checkbox-group@change="handleCheckeColumnChange"
<el-checkboxstyle="display:block;margin-left:20px"v-for="extendColumn inextendColumns1"
:label="extendColumn" v-model="extendColumn.isShow">{{extendColumn.name}}</el-checkbox>
v-model="extendColumns2">
</el-checkbox-group>
<el-checkboxlabel="全选"v-model="extendColumnShowAll" @change="handleCheckAll"></el-checkbox>
<el-dropdown-menuslot="dropdown">
</el-dropdown-menu>
<el-dropdownstyle="float:right">
</el-dropdown>
复选框
2018年11月9日
11:18
分区element 的第21 页
fn（）
this.$confirm('确认删除？').then(()=>{
console.log('取消删除')
}).catch(()=>{
})
searchEquipOp.updateAteProject(subItem).then(re=>{
message: "添加成功",
title: "操作提示",
type: "success",
offset: 100
})
this.$notify({
}).catch(er=>{
message: "添加失败:" + e,
this.$notify({
title: "操作提示",
offset: 100
})
type:'error', //success/warning/info/error
})
this.$message('这是一条消息提示');
this.$message({
message: '这是一条带有提示类型的消息',
type: 'success' //success/warning/info/error
});
confirmButtonText: '确定',
cancelButtonText: '取消',
type: 'warning'
this.$confirm('保存成功, 是否进行归档?', '提示', {
this.openCreateDialog();
}).then(() =>{
}).catch(() =>{})
confirmButtonText: '确定',
type: 'warning',
callback: action =>{}
this.$alert('你没有删除指标的权限', '警告', {
});
confirmButtonText: '确定',
type: 'info',
message: `action: ${ action }`}); }
this.$message({
callback: action =>{
this.$alert('这是一段内容', '标题名称', {
提示框
2018年11月13日
14:53
分区element 的第22 页
使用下拉菜单显示列
1 定义下拉菜单
2定义table隐藏项目
必须要使用v-if？
3定义下拉菜单数组
<iclass="el-icon-arrow-down el-icon--right"></i>
<el-buttontype="primary"round>显示列
</el-button>
<el-checkbox:label="extendColumn.name" v-model="extendColumn.isShow"></el-checkbox>
<liv-for="extendColumn inextendColumns1" >
</li>
<ulstyle="width:160px">
</ul>
<el-dropdown-menuslot="dropdown">
</el-dropdown-menu>
<el-dropdown>
</el-dropdown>
<el-table-columnproperty=""label="所属测试用例D1"v-if="extendColumns1[0].isShow"></el-table-column>
<el-table-columnproperty=""label="跳转1"v-if="extendColumns1[1].isShow"></el-table-column>
extendColumns1:[{name:"所属测试用例D1",isShow:false},{name:"跳转1",isShow:false}],
dropdown
2018年11月15日
10:50
分区element 的第23 页
内外层嵌套，内层添加append-to-body属性
append-to-body属性
外层内容
内层内容
<el-dialog width="30%" title="内层Dialog" :visible.sync="innerVisible" append-to-body>
</el-dialog>
<el-button @click="outerVisible = false">取消</el-button>
<el-button type="primary" @click="innerVisible = true">打开内层Dialog</el-button>
<div slot="footer" class="dialog-footer">
</div>
<el-dialog title="外层dialog" :visible.sync="outerVisible">
</el-dialog>
this.bpmnDiagramContainer = this.$refs.svg;
this.bpmnDiagramContainer.innerHTML = ''
this.$nextTick(()=>{
// console.log(this.bpmnDiagramContainer)
})
打开dialog后获取里面的元素使用nextTick
通过dialog打开子组件注意事项：
<el-dialog title="子组件标题" :visible.sync="childvisible" @open="openDialog">
<full-system ref="fullSystem" :systemData='systemData' ></full-system>
</el-dialog>
1点击父组件的事件fn1(){this.childvisible = true}
2dialog打开的事件openDialog(){this.$nextTick(()=>{this.$refs.childComponent.init()})
ref 区分大小写，调用打开的dialog组件元素要使用nextTick
3向子组件传值：子组件props:{systemData:Array},
dialog
2018年11月16日
11:55
分区element 的第24 页
<template>
<el-tabs v-model="activeName" @tab-click="handleClick">
<el-tab-pane label="用户管理" name="first">用户管理</el-tab-pane>
<el-tab-pane label="配置管理" name="second">配置管理</el-tab-pane>
<el-tab-pane label="角色管理" name="third">角色管理</el-tab-pane>
<el-tab-pane label="定时任务补偿" name="fourth">定时任务补偿</el-tab-pane>
</el-tabs>
</template>
<script>
export default {
data() {
return {
activeName: 'second'
};
},
methods: {
handleClick(tab, event) {
console.log(tab, event);
}
}
};
</script>
tab
2018年11月22日
16:05
分区element 的第25 页
<div class="pagination-wrapper ">
<el-pagination
@size-change="handleSizeChange"
@current-change="handleCurrentChange"
@prev-click="prevClick"
@next-click="nextClick"
:current-page="currentPage"
:page-sizes="[10, 20, 30, 40]"
:page-size="pageSize"
layout="total, sizes, prev, pager, next, jumper"
:total="pageTotal">
</el-pagination>
</div>
tableData1:{
computed:{//计算属性slice表格显示数据
get(){
var start = (this.currentPage-1)*this.pageSize
var length = this.pageSize
var end = this.currentPage * this.pageSize
return this.tableData.slice(start,end)
},
set(){
}
}
handleSizeChange(val){//分页更改显示条数
// console.log(val)
this.pageSize = val
},
handleCurrentChange(val){//分页更改当前页码
// console.log(val)
this.currentPage = val
},
prevClick(val){//分页前一页会触发handleCurrentChange不需要写这个
this.currentPage = val
},
nextClick(val){//分页后一页会触发handleCurrentChange
this.currentPage = val
},
分页
2018年11月29日
16:22
分区element 的第26 页
使用vuex传值三部
1State:{paramValues
changeParamValues(state,val){
state.paramValues = val;
2mutations：{
},
3this.$store.commit('changeParamValues', this.rulesContent);
监听
深度监听对象内部的属性
1使用deep:true 深度监听
2使用computed做中间层，然后浅监听
watch: {msg: {handler(newValue, oldValue) {console.log(newValue)},deep: true}}
如果监听对象内的某一具体属性，可以通过computed做中间层来实现
computed: {channel() {return this.msg.channel}},watch:{channel(newValue, oldValue) {console.log('new: %s, old: %s', newval, oldVal)}}
路由跳转传参数a跳到b
a把要跳转的参数传递到store，b去store里拿这个数据
1通过vuex传递
a组件
sendParams () { this.$router.push({ path: 'yourPath', name: '要跳转的路径的 name,在 router 文件夹下的 index.js 文件内找', params: { name: 'name', dataObj: this.msg } /*query: { name: 'name', dataObj: this.msg }*/ }) }
b组件
methods: { getParams () { // 取到路由带过来的参数 let routerParams = this.$route.params.dataobj // 将数据放在当前组件的数据内 this.msg = routerParams } }, watch: { // 监测路由变化,只要变化了就调用获取路由参数方法将数据存储本组件即可 '$route': 'getParams' }
2通过路由跳转传参实现
True和false属性值：
属性true和false的赋值，必须使用v-bind
:inline="true"
关于vue的DOM更新问题
1通过直接更改对象属性或数组项是无法实现表格表单对应数据刷新
1针对对象
Obj.prop = value 无法实现，需使用
Vue.set(obj,'prop',value)
2针对数组，
arr[index] = value 无法实现，需使用
Vue.set(arr,index,newValue)或者
Arr.splice(index,1,newValue)
2018年11月3日
15:37
分区vue 的第27 页
constpath = `${C.paramlibAddr}/api/v1/filetrans/savefile/string/${fileId}/${updateBy}`
returnAXIOS.post(path, model)
exportfunctionsubmitSequence(model: any,fileId:string,updateBy:string) {
}
{"data": this.stringToByte(this.equipJsonConfig)},
this.fileIdTemp,
this.userId
).then()
调用：ParamLibOp.updateJsonConfig(
post请求与调用
get请求与调用
constpath = `${C.paramlibAddr}/api/v1/paramapply/deleteParamApply/${id}`
returnAXIOS.get(path);
exportfunctiondeleteParamApply(id: number) {
}
ParamApplyOp.deleteParamApply(otherItem.tableId)
constpath = `${C.paramlibAddr}/api/v1/paramapply/getParamApply/${productName}/${productVersion}/${updatedBy}/${productType}/${productId}`
returnAXIOS.get(path);
exportfunctiongetParamApply(productName:string,productVersion:string,updatedBy:string,productType: string, productId: string) {
}
ParamApplyOp.getParamApply(this.selected.name,this.version_config[0].value,this.userId,this.selected.productType, current).then(
constpath = `${C.paramlibAddr}/api/v1/paramapply/del/bom?projectName=${projectName}&version=${version}&updatedBy=${updatedBy}&bom=${bom}`
returnAXIOS.get(path);
exportfunctiondelBoms(projectName:string,version:string,updatedBy:string,bom:string) {
}
ParamApplyOp.delBoms(this.selected.name,this.version.value,this.userId,this.product_id).then
更改请求头
AXIOS.defaults.headers.post['Content-Type'] = 'application/json';//或者使用对象如下
exportfunctiongetSequence(model:any) {
// const path = `${C.paramlibAddr}/api/v1/sequenceApply/getSequenceInfo`
constpath = `http://10.74.195.122:30072/api/v1/sequenceApply/getSequenceInfo`//苏学奋
returnAXIOS.post(path,model)
// return AXIOS({
// method: 'post',
// url: path,
// data: model,
// headers: {"Content-Type":"application/json"}
// })
}
接口
GET /api/v1/project/getProjectInfo/{productName}
Request URL
http://10.57.22.229:30072/api/v1/project/getProjectInfo/SmarX1125-XRRU-2020L
script:
import AXIOS from "axios";
import {HostConfig as C} from "../config";
Path：
AXIOS.get(Path).then((re)=>{data=re.data}).catch((err)=>{console.log(err)})
var _this = this;
var productName = this.productName;
接口为
get/api/v1/sequenceApply/downloadFile
参数
/?id=${id}
接口为
POST /api/v1/sequenceApply/updateJsonArray/string/{fileId}
参数
/${fileId}
model
AXIOS
2018年11月16日
18:23
分区vue 的第28 页
var productName = this.productName;
const versionPath = `${C.paramlibAddr}/api/v1/project/getVersions/${productName}`;
AXIOS.get(versionPath)
.then(function (response) {
// console.log('softwaresData',response.data)
_this.versionsList = response.data.reverse();
_this.productVersion = _this.versionsList[0];
_this.getSoftwaresData(_this.productVersion); //获取最新版本信息和软件清单
})
.catch(function (err) {
console.log(err);
});
分区vue 的第29 页
Vue.set(this.formEdit2, "toTEs", []);
关于点击调取后台数据页面渲染不同步问题
1 数据定义时如果是空
2 获取到的数据要使用
Vue.set(this.formEdit2, "toTEs", []);
3 或者是在数据定义的时候添加对应的键值，赋值为空
调试过程，
1 sources找到对应行代码，打断，刷新，F10逐行调试F8？？
后台返回500，查看preview 的message
vue文件的断点调试，不是在dist里面的文件
而是在webpack中的vue文件，函数里面
调试
2018年11月21日
11:10
分区vue 的第30 页
importVue from'vue';
importVuex from'vuex';
Vue.use(Vuex)
State:{},
Get(state){}
Getters:{
},
Fn(state,val){}
Mutations:{
},
Actions:{}
{
}
conststore=newVuex.Store(
)
exportdefaultstore;
Store.js
importstore from'./store/store.js'
router,
store,
el: "#v-app",
render: h =>h(App)
newVue({
})
Main,js
importstore from'../store/store.js'
userId: this.$store.state.username,
其他组件中
Vuex
Axios
importAXIOS from'axios'
import{ HostConfig asC } from'../config'
AXIOS.defaults.withCredentials = true;
constpath = `${C.paramlibAddr}/api/v1/right/login`
returnAXIOS.post(path,model);
exportfunctioncheckUserLogin(model:any) {
}
Main.js
importVue from'vue'
importElementUI from'element-ui'
import'element-ui/lib/theme-chalk/index.css';
Vue.use(ElementUI)
Element-ui
Main.js
import'bootstrap/dist/css/bootstrap.min.css'
Bootstrap:
Main.js
importVue from'vue'
importVueRouter from'vue-router'
Vue.use(VueRouter)
routes: [
]
constrouter = newVueRouter({
})
router,
store,
el: "#v-app",
render: h =>h(App)
newVue({
})
Vue-router
:class="{checkList2:true或false}"
给对象添加新的属性并赋值
obj['newProp'] = value
如果添加的属性是变量，不用加引号obj[newProp] = value
给对象item1增加新对象item2的所有属性
Object.assign(item1, item2);
插件
2018年11月22日
14:07
分区vue 的第31 页
Npminstall
添加项目插件
项目运行问题
2018年11月27日
10:16
分区vue 的第32 页
router传参
传递
this.$router.push({
path: "/00",
query: {
ateName:transferProject.ateName,
}
})
接收
mounted(){
var getQuery = this.$route.query;
this.ate_Name = getQuery.ateName.trim();
}
router
2018年12月7日
10:25
分区vue 的第33 页
对象数组排序比较器
returnfunction(a,b){
varx=a[prop];
vary=b[prop];
returntypeoffn ==='function'?fn(a,b):0;
if(x===y){
returnx>y?-1:1;
} else{
}
}
compare1(prop,fn){
},
当前时间戳：
第一种方法：
vartimestamp = Date.parse(new Date());
结果：1280977330000
第二种方法：
vartimestamp = (new Date()).valueOf();
结果：1280977330748
第三种方法：
var timestamp=new Date().getTime()；
结果：1280977330748
第四种方法：
var timestamp= Date.now();
格式化时间戳
newDate(timestamp).toLocaleString()
转义无非是两种情况：1：将普通字符转为特殊用途，一般是编程语言中，用于表示不能直接显示的字符，比如后退键，回车键，等。2：用来将特殊意义的字符转换回它原来的意义
对象转换为字符串{}=>"[object Object]"
怎么在对象数组外面加双引号
JSON.stringify(arr)
JSON.stringify() 方法用于将JavaScript 值转换为JSON 字符串
JSON.parse() 方法用于将一个JSON 字符串转换为对象
扩展运算符，将一个数组转为用逗号分隔的参数序列 ...arr.slice(0)
JSON.stringify() 方法用于将JavaScript 值转换为JSON 字符串
JSON.parse() 方法用于将一个JSON 字符串转换为对象
Vue.set(this.rulesContent, 'enum', []);
Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用for...in 循环遍历该对象时返回的顺序一致
Object.getOwnPropertyNames(obj) 获取对象可遍历属性
Object.assign(item, items); 合并对象
delete item[key];
arr.push(item)
.Trim()移除字符串两侧空格
input 事件oninput 事件在用户输入时触发，它是在元素值发生变化时立即触发
change 事件 要在input 失去焦点的时候才会触发；
api
2018年11月6日
9:34
分区js 的第34 页
JavaScript内存管理
https://github.com/wengjq/Blog/issues/1
内存泄漏可以定义为应用程序不再需要的内存，因为某种原因其不会返回到操作系统或可用内存池
垃圾回收语言泄漏的主要原因是不需要的引用
常见的JavaScript 内存泄漏
1意外的全局变量
添加'use strict'; 在您的JavaScript文件的开头。这使得能够更严格地解析JavaScript以防止意外的全局变量。
使用全局变量来存储大量数据，请确保将其置空或在完成后重新分配它
2被遗忘的计时器或回调函数
3脱离 DOM 的引用
假设您在JavaScript代码中保留对表的特定单元格（标记）的引用。在将来的某个时候，您决定从DOM中删除表，但保留对该单元格的引用。直观地，可以假设GC将回收除了该单元之外的所有东西。在实践中，这不会发生：单元格是该表的子节点，并且子级保持对其父级的引用。换句话说，从JavaScript代码对表单元格的引用导致整个表保留在内存中。在保持对DOM元素的引用时仔细考虑这一点。
4闭包
Chrome内存分析工具 TimeLine 更名Performance Profiles
基本上有两种类型的泄漏：1、泄漏引起内存使用的周期性增加。2、一次发生的泄漏，并且不会进一步增加内存。
产l00370656
144不会持续增加
装test20181107
157 不会持续增加
装test2020
194-163
装test20181107
198-151
装test2020
215
装testliao_project
477
内存泄漏问题
2018年11月14日
14:44
分区js 的第35 页
分区js 的第36 页
<divclass="tab-content"v-html="previewXml"></div>
this.previewXml = '<xmp>'+ re.data.xmlStr + '</xmp>';
格式化xml
格式化json
xml显示
json显示
<divclass="tab-content"v-html="previewJson" ></div>
resultJson+=formatFile.formatJson(item)
re.data.jsonArray.forEach((item)=>{
})
varresultJson = ''
this.previewJson = '<pre>'+ resultJson + '</pre>';
比较两个对象是否相同
varaProps = Object.getOwnPropertyNames(a);
varbProps = Object.getOwnPropertyNames(b);
// console.log(aProps,bProps)
aProps.pop() // 剔除"__ob__"
bProps.pop()
// console.log('length不同')
returnfalse;
if(aProps.length != bProps.length) {
}
varpropName = aProps[i];
// console.log('value不同,不同项：', propName)
returnfalse;
if(a[propName] !== b[propName]) {
}
for(vari = 0; i < aProps.length; i++) {
}
isObjectValueEqual(a, b) {//比较两个对象是否相同
xml文件Json文件显示
2018年11月17日
16:15
分区js 的第37 页
}
returntrue;
},
分区js 的第38 页
exportfunctiongetCookie(name){
vararr,reg=newRegExp("(^|)"+name+"=([^;]*)(;|$)");
if(arr=document.cookie.match(reg))
return(arr[2]);
else
returnnull;
}
exportfunctionsetCookie(c_name,value,expiredays){
varexpdate = newDate();
if(window.navigator.userAgent.indexOf('Chrome') !== -1) {
//chrome有时差8个时区
expiredays = expiredays + 1/3;
}
expdate.setDate(expdate.getDate()+expiredays);
document.cookie=c_name+"="+escape(value)+((expiredays==null)?"":";expires="+expdate.toGMTString());
}
//删除cookies
exportfunctiondelCookie(name)
{
varexp = newDate();
exp.setTime(exp.getTime() -1);
varcval=getCookie(name);
if(cval!=null) document.cookie= name + "="+cval+";expires="+exp.toGMTString();
}
cookie
2018年11月21日
17:14
分区js 的第39 页
API
indexOf()方法用于查找元素在数组中第一次出现时的索引，如果没有，则返回-1。
arr.indexOf(element, fromIndex=0)
element 为需要查找的元素。
fromIndex 为开始查找的位置，缺省默认为0。如果超出数组长度，则返回-1。如果为负值，假设数组长度为length，则从数组的第length + fromIndex项开始往数组末尾查找，如果length + fromIndex<0 则整个数组都会被查找
indexOf使用严格相等
find()返回数组中第一个满足条件的元素（如果有的话），如果没有，则返回undefined。
findIndex()它返回数组中第一个满足条件的元素的索引（如果有的话）否则返回-1。
语法：arr.find(fn, thisArg)，arr.findIndex(fn, thisArg)
fn 表示在数组每一项上执行的函数，接受三个参数：
value 当前正在被处理的元素的值
index 当前元素的数组索引
array 数组本身
thisArg 可选，用来当做fn函数内的this对象
arr.findIndex(function(value,index,array){
return value>5
})
to.matched.some( m => m.meta.auth)
//match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。返回值是存放匹配结果的数组
some方法测试数组中的某些元素是否通过了指定函数的测试
some 测试数组元素时，只要有一个函数返回值为true，则该方法返回true，若全部返回false，则该方法返回false。
var arr=[1,2,3,4,5]
var b=arr.some(function(item){
console.log(item);
return item > 10;
})
console.log(b) 测试条件要是用return返回判断值
splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。
Splice:
Vara = [1,2,3]
Var b = Arr.splice(2,1)
a//[1,2]
b//[3]
更改原数组，返回更改值（删除的元素）
filter()数组过滤方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素,如果没有符合条件的元素则返回空数组,
filter() 不会改变原始数组
array.filter(function(currentValue,index,arr), thisValue)
thisValue可选。对象作为该执行回调时使用，传递给函数，用作"this" 的值。
如果省略了thisValue ，"this" 的值为"undefined"
var arr=[1,2,3,4,5];
var a=3;
var brr=arr.filter(function(item){
return item > a;
})
forEach()方法用于调用数组的每个元素，并将元素传递给回调函数；返回值undefined
var crr=arr.forEach(function(item,index){
arr[index] = item + a
})
map()方法遍历数组，使用传入函数处理每个元素，并返回函数的返回值组成的新数组
数组
数据类型转换
判断对象中是否具有某个属性
数组
2018年11月21日
17:37
分区js 的第40 页
分区js 的第41 页
switch(n){case 1: 执行代码块1 break;case 2: 执行代码块2 break;default: n 与case 1 和case 2 不同时执行的代码}
语法
2018年11月23日
18:19
分区js 的第42 页
需求或DTS单号：NA
修改原因：解决fullSystem组件删除增加按钮布局问题
修改人：renyupeng rWX619768
需求或DTS单号：NA
修改原因：解决searchFile组件数据传递初始化问题
修改人：renyupeng rWX619768
rWX619768
本机ip
ipconfig
10.40.89.189
子网255.255.254.0
网关10.40.88.1
申请开通svn权限：
申请地址http://iright.huawei.com/pages/Default.aspx
教程http://3ms.huawei.com/km/blogs/details/5530175
RCC-HUMEP_V5R3
咱们的群组名称
段斌审批
项目访问：http://10.57.22.229:30072" 改为自己的ip
SVN版本库地址：
前台界面：http://szxsvn06-rd:6801/svn/CP_ZB_SVN/HUMEP/HUMEP V500R003/iTestCommander外包代码/Branches/5G_iTestCloud/configproducer-web
第一次直接检出
先更新后提交
选择性提交更改的文件，
提交备注：（严格按照格式进行备注，没有分号，注意空格）
需求或DTS单号：NA
修改原因：1.解决searchFile组件数据传递初始化问题
修改人：renyupeng rWX619768
修改原因：1.创建bom或者复制bom时判断bomid是否已经存在了2. 将版本与bom顺序对调 3.切换工程时刷新bom下拉框
4.修复创建新bom导入指标库指标数据报错的问题
svn
2018年11月26日
18:34
分区笔记的第43 页
修正已登录用户，刷新不在重复登录
svn 冲突：
假设A、B两个用户都在版本号为100的时候，更新了svnsource.txt这个文件。A用户在修改完这个文件之后提交到服务器，这时是提交成功的，此时svnsource.txt文件的版本号已经变成101了。同时B用户在版本号为100的svnsource.txt文件上做修改，修改完之后提交到服务器时，由于不是在当前最新的101版本上做的修改，所以导致提交失败,产生冲突
版本冲突：
1备份自己的文件后删除，重新检出，在做修改后，更新提交
2B用户将文件提交到服务器时，提示版本过期：首先应该从版本库更新版本，然后解决冲突。冲突解决后要执行svn resolved(解决)，最后再签入到版本库。在冲突解决之后，需要用svn resolved(解决)来告诉SVN冲突解决，这样才能提交成功。
解决冲突有三种选择：
一．放弃自己的更新，使用svn revert(回滚)，然后提交。此方式下不需要用svn resolved(解决)。
二．放弃自己的更新，使用别人的更新。使用最新获取的版本覆盖目标文件，执行resolved filename并提交(选择文件-右键-解决)。
三．手动解决:冲突发生时，通过和其他用户沟通后，手动更新目标文件，然后执行resolved filename来解决冲突，最后提交。
解决步骤如下：
1. 在当前目录下执行update(更新)操作；
2. 在冲突文件上，选中文件-右键-TortoiseSVN-Edit conflicts(解决冲突)，出现三个窗口：
Theirs窗口-为当前服务器上最新版本
Mine窗口-为本地修改过的版本
Merged窗口-为合并后的文件内容显示
3. 如果要使用服务器版本，在Theirs窗口选中差异内容，右键，选择User this text block。同理，如果要使用本地版本，在协商后，在Mine窗口，右键，选择User this text block。
4. 修改完成后，保存svnsource.txt文件内容。
5. 在B用户的冲突目录下，选中文件-右键-TortoiseSVN-Resolved。会列出冲突的文件列表，如果确认已经解决，点击OK。冲突解决。
6. 提交冲突解决后的文件。
如何降低冲突解决的复杂点：
1. 在文档编辑完成后，尽快提交，频繁的更新/提交可以降低冲突发生的概率，以及发生时解决冲突的复杂度。
分区笔记的第44 页
2. 在每次提交时，写上明确的message，方便以后查找用户更新的原因。毕竟随着时间的推移，对当初更新的原因有可能会遗忘。
3. 养成良好的使用习惯，使用svn前每次都先更新，后提交。每天早上打开后，首先要从版本库获取最新版本，每天下班前必须将已经编辑的文档提交到版本库。
分区笔记的第45 页
命令行
1、常用命令行工具：
①cmd ②powershell ③git bash
2、命令行常用命令（在git bash上生效，部分在cmd无用）
-pwd (print working directory) 查看当前所在路径--绝对路径
-cd(change directory) 切换目标
-ls(list) 查看当前目录下的内容
-mkdir(make directory) 创建目录
-touch 创建文件
-cat 查看文件内容（一次性将内容全部显示）
-less 查看文件内容（显示部分信息）--再次输入‘回车’一行一行显示，‘空格’一页一页显示，‘b’一次向上走一页
-rm(remove) 删除文件，-rm -rf 文件夹（循环递进删除文件夹）
-rmdir(remove directory)删除文件夹（只能删除空文件夹，不常用）
-clear 清屏
-q 退出
-mv(move) 移动文件或重命名
-cp(copy) 复制文件
-echo ‘内容’> 文件名（输出内容到文件中，每次输入都是覆盖原来的文件）
-echo ‘内容’>>文件名（输出内容到文件中，每次输入都是追加新内容）
3、Git介绍
Git版本管理工具，有三大区域：
①工作目录-----存放项目代码的目录
②暂存区-----存放工作中更改的文件，避免项目代码丢失。
③代码仓库-----当开发功能足够成为一个版本时，提交到仓库。其实就是将暂存区中代码复制一份存储到代码仓库中。
默认我们一期版本已经上线，二期代码分支版本大家从今天起都先提交到华为内部isource源代码归档平台
1、前台代码git地址：
http://isource-dg.huawei.com/l00311151/CloudATEConfigWeb.git
先pull先commit后push
后台代码：
http://isource-dg.huawei.com/l00311151/CloudATEConfig.git
本地删除的文件恢复：
看看工作区的变化
git status
查看文件变动deleted:Application/Home/View/Index/Index.html modified修改
记住删除文件的路径
拉取最近一次提交到版本库的文件到暂存区 改操作不影响工作区
git reset HEAD Application/Home/View/Index/Index.html（注释：上面的那个路径）
Unstaged changes after reset:
D Application/Home/View/Index/Index.html
恢复删除的文件
git checkout Application/Home/View/Index/Index.html
git
2018年11月26日
18:34
分区笔记的第46 页
Git常用命令
①配置git用户名和密码
git config --global user.name sun
git config --global user.email sun@qq.com
②查看当前git的配置
git config --list
③初始化git 仓库
git init
④查看当前仓库的状态
git status
⑤将工作目录中的文件添加到暂存区
git add sun.html（这个命令上传一个文件）git add .(这个命令会将当前目标下所有文件上传) git add a.txt b.txt (如果上传多个，文件名之间用空格)
题外话：如果当前文件夹内文件很多，但是有些又不想提交。可以通过编辑器（sublime,webstorm等）或命令行创建一个文件以.gitignore后缀，其内容写入不想提交的文件名即可。此时再通过git add .命令去全部提交时就会有选择提交。
⑥将暂存区中的代码提交到本地仓库，形成一个版本
git commit -m 备注（如果备注内容带空格，则需要加‘’）
⑦查看本地仓库中的历史提交版本
git log
⑧将暂存区中文件删除
git rm --cached 文件名
注意：1、必须保证工作目录中代码和暂存区中代码一致。2、删除之后，工作目录中仍然有此文件而暂存区没有。git不将管理该文件。
⑨用暂存区中的文件覆盖工作目录中的文件
git checkout --文件名
注意：暂存区和工作目录中均有此文件，该文件依然被git管理
⑩回滚到本地仓库中特定版本并覆盖暂存区和工作目录
git reset --hard commitID(commitID可以到git log中查看提交编号)，有种方式：1、全部黏贴2、只取前6位
注意：如果有版本1，版本2（后提交），当回滚到版本1时版本2会被自动删除。
图示：
分支相关命令：
①查看分支
git branch (显示结果中有* 代表当前所在分支)
②创建分支
git branch 分支名称
③切换分支
git checkout 分支名称
④创建并切换分支
git checkout -b 分支名称
⑤删除分支（如果分支没有被合并不允许删除）
git branch -d 分支名称
⑥删除分支（强制删除分支）
git branch -D 分支名称
⑦合并分支
git merge 来源分支（意思：当前目录到主分支，将来源分支合并到主分支上。合并后来源分支仍然存在）
4、github 相关命令介绍
4.1 模拟一个公共代码仓库
①先初始化git init --bare sun.git （注意：此时公共代码仓库的文件夹必须以.git为后缀名）
4.2 github仓库
①为远程仓库地址创建别名
git remote add origin https://github.com/sun766/Programming-art.git（此处举例）
注意：通常我们会把远程仓库地址设置别名为origin
②查看远程地址的详细信息
git remote -v
③查看当前别名所对应的远程仓库地址
git remote show origin
④从远程仓库获取代码（拉取所有版本到本地）
git clone origin
注意：加入到已有项目的开发中，需要先拉取所有版本到本地再进行开发。
⑤从远程仓库拉取代码（拉取最新版本到本地，开发过程中使用）
git pull origin master
面试题：说出clone 和pull 之间区别
⑥向远程仓库推送代码
git push origin(远程仓库地址) master(本地分支名称)：master(远程分支名称)
分区笔记的第47 页
git push origin(远程仓库地址) master(本地分支名称)：master(远程分支名称)
注意：推送时一定要在本地代码仓库目录中，如果本地分支同远程分支名称一样，可以只写一个。
⑦删除当前别名所对应的远程仓库地址
git remote remove origin
记住：如果你想重新使用origin 别名，则需要将原来的origin 对应远程地址删除掉。
‘’多人协作开发免登录设置”
当不想使用账户和密码进行推送代码时，建议使用SSH协议。
在git bash 中输入ssh-keygen，自动会在c:/用户/administrator/中生成.ssh文件。其包括三个文件
①id_rsa ②id_rsa.pub ③known_hosts
在github账号中settings/SSH and GPG keys，点击New SSH key将②中内容复制粘贴。
注意：设置别名时用SSH路径。
来自<http://www.cnblogs.com/WangXinPeng/p/8016293.html>
分区笔记的第48 页
关于端口和进程：
使用netstat -an可以查看本机有哪些端口在监听
在windows下如何查看80端口占用情况?是被哪个进程占用?如何终止
查看80端口进程号
netstat -aon | findstr "80"
TCP 0.0.0.0:80 0.0.0.0:0 LISTENING 1688 可以看出80端口被进程号为1688的程序占用.
查看进程号程序
tasklist | findstr "1688"
inetinfo.exe 1688 Console 0 2,800 K 可以看出是inetinfo占用了80端口;
终止进程
taskkill /pid 1688 /F
成功: 已终止PID 为1688 的进程。
查看进程号
tasklist | findstr "1688"
再次确认是否成功终止,如果成功终止此次执行命令后应返回空.
cmd
2018年11月26日
18:29
分区笔记的第49 页
Vue.set(this.formEdit2, "toTEs", []);
关于点击调取后台数据页面渲染不同步问题
1 数据定义时如果是空
2 获取到的数据要使用
Vue.set(this.formEdit2, "toTEs", []);
3 或者是在数据定义的时候添加对应的键值，赋值为空
调试过程，
1 sources找到对应行代码，打断，刷新，F10逐行调试F8？？
后台返回500，查看preview 的message
vue文件的断点调试，不是在dist里面的文件
而是在webpack中的vue文件，函数里面
调试
2018年11月26日
18:34
分区笔记的第50 页
svn
前台界面：http://szxsvn06-rd:6801/svn/CP_ZB_SVN/HUMEP/HUMEP V500R003/iTestCommander外包代码/Branches/5G_iTestCloud/configproducer-web
内网的npm环境设置:
设置组件的本地保存位置：
npm config set cache "D:\nodejs\node_cache"
npm config set prefix "D:\nodejs\node_global"
在安装的文件夹【D:\node】下创建两个文件夹【node_global】及【node_cache】
进入环境变量对话框，在【系统变量】下新建【NODE_PATH】，输入【D:\node\node_global\node_modules】，将【用户变量】下的【Path】修改为【D:\node\node_global】
另外再加一条环境变量，意思大概是nodejs不要对https证书做校验，要不很多包下载的时候会报错
key：NODE_TLS_REJECT_UNAUTHORIZED
value：0
NPM源使用说明
npm config rm proxy
npm config rm http-proxy
npm config rm https-proxy
npm config set no-proxy .huawei.com
npm config set registry http://rnd-mirrors.huawei.com/npm-registry/
npm文件
no-proxy=.huawei.com
strict-ssl=false
_auth=YXZlbnVlLXVzZXI6QVA0SndwTHpYRUM4M21BUXRnd3Y5U1gyWDM2
always-auth=true
email=avenue-user@huawei.com
registry=https://szxy1.artifactory.cd-cloud-artifact.tools.huawei.com/artifactory/api/npm/sz-npm-public
测试：
npm install express -g # -g是全局安装的意思
以当前文件夹为工程根目录，创建package.json文件：
npm init
安装工程运行时依赖的组件，并在package.json中记录组件版本信息：
npm install --save <XXX组件> <YYY组件>
安装工程开发、预处理时依赖的组件，并在package.json中记录组件版本信息：
npm install --save-dev <XXX组件> <YYY组件>
安装package.json中记录的工程依赖的全部组件：
npm install
执行package.json中定义的某项scripts命令：
npm run <scripts命令>
npm run vendor-build
npm run dev
使用config中的http://10.57.22.229:30072更改前面的地址为自己ip地址进行访问
.npmrc
npm install bpmn-js
安装到生产环境？
在package.json 文件里面体现出来的就是，
使用--save-dev 安装的插件，被写入到devDependencies 域里面去，
而使用--save 安装的插件，则是被写入到dependencies 区块里面去。
都不适用默认安装到dependencies
"bpmn-js": "^3.0.2",
devDependencies里面的插件只用于开发环境，不用于生产环境，
而dependencies 是需要发布到生产环境的
比如我们写一个项目要依赖于jQuery，没有这个包的依赖运行就会报错，这时候就把这个依赖写入dependencies ；
而我们使用的一些构建工具比如glup、webpack这些只是在开发中使用的包，上线以后就和他们没关系了，所以将它写入devDependencies。
npm
2018年11月26日
18:35
分区笔记的第51 页
华为账号：rWX619768
易宝账号：SZ001884
共享文件操作：
文件夹右键，共享至特定用户，输入工号，复制链接
5G_uTestCloud (file://SZXY1RWX6197681/5G_uTestCloud)
更改ip
file://10.40.89.189/5G_uTestCloud
更改为\\10.40.89.189\5G_uTestCloud发送给其他人，后可以直接点击
我们下个项目前台需要使用的框架是avenue3的标准，前端开发有空可以看看,互相交流学习下：
前端组件库：http://avenueui.alpha.tools.huawei.com/avenueui3/src/dev.php?m=card
UI规范：http://avenueui-ng.inhuawei.com/components/InspireUI
后台部署：使用云龙流水线、自助发布
node_modules (file://SZXY1RWX6197681/node_modules)
\\10.40.89.189\node_modules
笔记
2018年12月5日
10:35
分区笔记的第52 页
svg使用xml编写
svg文件必须使用.svg后缀名保存
可以在浏览器中直接打开
<?xml version="1.0" standalone="no"?> <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"> <svg width="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"> <circle cx="100" cy="50" r="40" stroke="black" stroke-width="2" fill="red"/> </svg>
第一行包含了XML 声明。请注意standalone 属性！该属性规定此SVG 文件是否是“独立的”，或含有对外部文件的引用。
standalone="no" 意味着SVG 文档会引用一个外部文件-在这里，是DTD 文件。
第二和第三行引用了这个外部的SVG DTD。该DTD 位于“http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd”。该DTD 位于W3C，含有所有允许的SVG 元素。
SVG 代码以<svg> 元素开始，包括开启标签<svg> 和关闭标签</svg> 。这是根元素。width 和height 属性可设置此SVG 文档的宽度和高度。version 属性可定义所使用的SVG 版本，xmlns 属性可定义SVG 命名空间。
SVG 的<circle> 用来创建一个圆。cx 和cy 属性定义圆中心的x 和y 坐标。如果忽略这两个属性，那么圆点会被设置为(0, 0)。r 属性定义圆的半径。
stroke 和stroke-width 属性控制如何显示形状的轮廓。我们把圆的轮廓设置为2px 宽，黑边框。
fill 属性设置形状内的颜色。我们把填充颜色设置为红色
<p>引入svg文件的几种方法：
1、通过iframe的src属性
2、通过object的data属性
3、通过embed的src属性
4、通过img的src属性
推荐使用iframe标签引入
</p>
<iframe:src="svg" width="300"height="100">
</iframe>
<object:data="svg" type=""></object>
<embed:src="svg"><embed>
<img:src="svg" alt="">
importsvgfrom"./svg.svg";
data() {
return{
svg:svg
矩形<rect>

圆形<circle>

椭圆<ellipse>

线<line>

折线<polyline>

多边形<polygon>

路径<path>

文本<text>

<defs>引用元素的容器

<g> 用于把相关元素进行组合的容器元素

路径：
M = moveto

L = lineto

H = horizontal lineto

V = vertical lineto

C = curveto

S = smooth curveto

Q = quadratic Belzier curve

T = smooth quadratic Belzier curveto

A = elliptical Arc

Z = closepath

<path d="M250 150 L150 350 L350 350 Z"
style="fill:rgba(255,255,255,0);stroke-width:1;stroke:rgb(0,0,0)" />
文本：
<text x="10" y="20" style="fill:red;">Several lines:
<tspan x="10" y="45">First line</tspan>
<tspan x="10" y="70">Second line</tspan>
</text>
画布无限大
视窗为svg的width和height
默认overflow:hidden,
只能通过更改设置overflow:visible 显示视窗以外的画布内容，设置scroll无效
视窗（svg元素）添加到一个div中，可以通过设置很大的视窗显示更多的画布上内容，然后容器可以滚动
viewport就是值指SVG图片本身可视区域的大小（视口）
viewbox用来定义svg的可视范围
当没有设置viewbox的时候，viewbox就是整个viewport的大小，而当我们设定了viewbox，等于就是告诉SVG，我指定的这个区域是我要显示的，SVG就会把这个区域放大到viewport的大小，比如电视机
preserveAspectRatio和viewbox是一个绝配的搭档，特别是当viewbox的值和viewport的值
//让svg滚动显示：视口变大，容器固定大小scroll
//更改svg元素的viewBox 大小调整到合适大小
svg.setAttribute('viewBox','100 0 1500 1000');
.svgcontainer{
height:1000px;
width:1500px;
overflow:visible;
}
.viewport{
transform:matrix(1,0,0,1,0,0)!important;
}
Transform
优点：可以做任意的缩放、平移、旋转，且可以用js动态更改属性。
缺点：不能在svg根元素中使用此属性，一般是给svg的所有直接子g元素添加此属性，才能达到缩放svg的效果
transform="translate(x-value, y-value)"
transform="scale(x-value, y-value)"
transform="rotate(angle,[centerX, centerY])"
transform="skewX(angle) skewY(angle)"
transform:matrix(a,b,c,d,e,f) 矩阵
如果是2D变换，括号里就是6个值得矩阵，如果是3D变换，括号里就是4*4的16值得矩阵
原始值
transform: matrix(1,0,0,1,0,0);
2018年11月29日
11:25
分区svg 的第53 页
preserveAspectRatio和viewbox是一个绝配的搭档，特别是当viewbox的值和viewport的值（也就是宽和高）不一样的时候，preserveAspectRatio属性就直接决定浏览器怎么来显示图片
preserveAspectRatio 属性用来强制统一缩放比，以保持图形的宽高比。
如果viewBox 的宽高比和SVG 视窗的宽高比不同，那么在拉伸viewBox 来适应视窗的时候，就可能导致SVG 图形发生扭曲。这个时候preserveAspectRatio 就派上用场了
preserveAspectRatio =<align><meetOrSlice>
viewBox="0 0 115 190"
viewBox 接收四个参数值，分别是min-x，min-y，width，height。
min-x和min-y决定了viewBox 的左上角，width和height决定了viewBox 的宽和高
viewBox变大，视口不变，可视范围增加，相当于缩小图片
viewBox变小，视口不变，可视范围减小，相当于放大图片
viewBox不变，视口变大，可视范围增加，相当于更改较大视口，然后viewBox减小，放大图片
相当于是把viewBox的内容放大或缩小到视口上显示
svg.setAttribute('viewBox','0 0 1300 500');
分区svg 的第54 页
